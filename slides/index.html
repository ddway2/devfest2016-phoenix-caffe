<html lang="en">
<head>
    <meta charset="utf-8">
    <title>C++ : The beast is Back</title>
    <link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/simple.css" id="theme">
    <link rel="stylesheet" href="css/my_style.css">
    <link rel="stylesheet" href="lib/css/zenburn.css"> 
</head>
<body>
<div class="reveal">
    <div class="slides">
        
        <!-- Titre 1 -->
        <section>
            <h1>C++</h1>
            <h1>The Beast is back !!</h1>
                        
        </section>
        
        <!-- Context -->
        <section>
            <a align="left"><h3>Présentation</h3></a>
            <img src="img/expandium-300x164.jpg" width="30%" style="float: right; border: none;"/>
            <div class="ulist">
                <ul style="width: 60%">
                    <li>10 ans d'expérience</li>
                    <li>Monitoring passif du coeur de réseau d'opérateurs télécom</li>
                    <li>Les opérateurs mobiles et les entreprises de chemain de fer (GSM-R)</li>
                    <li>Analyse / Business Intelligence</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Qui sommes-nous ?</h3>
            <h4>Pierre Salmon</h4>
                <img class="plain" src="img/cpp_img.jpg"/>
        </section>

        <section>
            <h3>Qui sommes-nous ?</h3>
            <h4>Nicolas Greffard</h4>
                <img class="plain" src = "img/data_science_venn.png" alt = "data_science_venn">
        </section>

        <section>
            <h2>Quelles sont nos problématiques ?</h2>
        </section>

        <section>
            <img width="30%" style="float:right; border: none; box-shadow: none" src="img/big-data.jpg"/>
            <ul style="width: 60%">
                <li>Gestion de gros volume</li>
                <li>Capacité de traitement</li>
                <li>Contrainte hardware</li>
                <li>Données sensibles</li>
                <li>Coût de maintenance</li>
            </ul>
        </section>

        <section>
            <h2>Pourquoi les technologies C++ ?</h2>
            <aside class="notes">
                <ul>
                <li>Performance</li>
                <li>Compétence</li>
                <li>Haut niveau / Matos</li>
                <li>Librairie existante</li>
                </ul>
            </aside>
        </section>

        <!-- Slide C++ -->
        <!-- Historique C++ -->
        <section>
            <h2>Au commencement : 1983</h2>
            <h3>C with Classes</h3>
            <div style="margin-top: 100px;">
                <img class="plain" src="img/220px-BjarneStroustrup.jpg"/>
                <h6>Bjarne Stroustrup</h6>
            </div>
        </section>
        
        <section>
            <h2>1998 : standard ISO</h2>
            <div style="margin-top: 100px">
                <img class="plain" src="img/iso_logo.gif"/>
            </div>
        </section>

        <section>
            <h2>2011 - 2014 : Le renouveau</h2>
            <div style="margin-top: 100px">
                <ul>
                    <li>Le langage C++</li>
                    <li>La bibliothèque Standard (STL)</li>
                    <li>La bibliothèque boost</li>
                </ul>
            </div>
        </section>

        <section>
            <img class="plain" src="img/cpp-evolution-path.svg"/>
        </section>

        <!-- Présentation des nouveauté -->
        <section>
            <h2>Luttons contre les idées reçus</h2>
        </section>

        <!-- Idée reçu n°1 -->
        <section>
            <h3>Idée reçu n°1 : <h3>
            <h3>"Il n'y a pas de Garbage Collector : il faut gérer soi même la mémoire et les objets"</h3>
            <aside class="notes">
                Définition du petit projet : un service dans le cloud qui échange des messages
            </aside>
        </section>

        <section data-markdown>
            <script type="text/template">
                Un pool de serveur TCP
                ```cpp
                class server_tcp {
                public:
                    uint32_t    id;
                    socket      sock;
                    // ... 
                };

                
                std::vector<server_tcp*>            server_tcp_pool;
                std::map<uint32_t, server_tcp*>     server_tcp_by_id;

                void new_server() {
                    server_tcp* srv = new server_tcp();
                    
                    server_tcp_pool.push_back(srv);
                    server_tcp_by_id[srv->id] = srv; 
                }

                // ... Un peu de traitement
                void shutdown() {
                    for (server_tcp* srv : server_tcp_pool) {
                        delete srv;
                    }
                    server_tcp_pool.clear();
                }
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Smart Pointer
                Le pointeur partagé
                ```cpp
                #include <memory>

                std::vector<std::shared_ptr<server_tcp>>            server_tcp_pool;
                std::map<uint32_t, std::shared_ptr<server_tcp>>     server_tcp_by_id;

                void new_server() {
                    server_tcp* srv =  std::make_shared<server_tcp>();
                    
                    server_tcp_pool.push_back(srv);
                    server_tcp_by_id[srv->id] = srv; 
                }

                /// Live your life server TCP variable...

                void shutdown() {
                    server_tcp_pool.clear();
                }
                ```
            </script>
            <aside class="notes">
                Ouvrir vers la gestion des variables (copie / valeur / move semantic)
            </aside>
        </section>


        <section data-markdown>
            <script type="text/template">
                Zoomons sur la partie d'envoie de paquet
                ```cpp
                class server_tcp {
                public:
                    struct packet {
                        uint64_t        req_id;
                        uint8_t         data[25_mo];
                        // ...
                    };
                public:
                    void send(packet p) {  /* ... */ }     // Passage par valeur

                    void run() {
                        while (!done()) {
                            packet pkt;

                            // ... un peu de traitement

                            send(pkt);
                        }
                    }
                };
                ```

            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                Améliorons cela avec un passage par référence
                ```cpp
                class server_tcp {
                public:
                    void send(packet& p) {  /* ... */ }     // Passage par référence

                    void run() {
                        while (!done()) {
                            packet pkt;

                            // ... un peu de traitement

                            send(pkt);
                        }
                    }
                };
                ```
            </script>
        </section>

        <section data-markdown>
            <!-- Faire un exemple en mode client serveur -->
            <script type="text/template">
                ### Move Semantic
                ...ou comment passer le controle d'une variable'
                ```cpp
                class server_tcp {
                public:
                    void send(packet&& p) {  /* ... */ }     // Passage par rvalue

                    void run() {
                        while (!done()) {
                            packet pkt;

                            // ... un peu de traitement

                            send(std::move(pkt));
                        }
                    }
                };
                ```
            </script>
            <aside class="notes">
                Mot-clé: responsabilité de la variable
                Exemple : send est une fonction multi thread
            </aside>
        </section>

        <!-- Mot clé auto -->
        <section>
            <h3>Idée reçu n°2</h3>
            <h3>"Il y a des déclarations de type partout ! </h3>
            <h3>Sans IDE c'est trop dure'"</h3>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Rechercher de l'instance d'un serveur
                ```cpp
                class server_tcp {
                public:
                    uint32_t    id;
                    socket      sock;
                    // ... 
                };

                std::vector<std::shared_ptr<server_tcp>>            server_tcp_pool;
                std::map<uint32_t, std::shared_ptr<server_tcp>>     server_tcp_by_id;
                
                ...

                std::map<uint32_t, std::shared_ptr<server_tcp>>::iterator found = server_pool.find(42);
                socket sock = found->second->sock;
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                On peut toujours utilisé un alias (using ou typedef)
                ```cpp
                class server_tcp {
                public:
                    uint32_t    id;
                    socket      sock;
                    // ... 
                };

                typedef server_tcp_pool_type std::vector<std::shared_ptr<server_tcp>>;
                using server_tcp_by_id_type = std::map<uint32_t, std::shared_ptr<server_tcp>>;

                std::vector<std::shared_ptr<server_tcp>>            server_tcp_pool;
                std::map<uint32_t, std::shared_ptr<server_tcp>>     server_tcp_by_id;
                
                ...

                std::map<uint32_t, std::shared_ptr<server_tcp>>::iterator found = server_tcp_by_id.find(42);
                socket sock = found->second->sock;
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Le mot clé auto à la rescousse...
                ```cpp
                class server_tcp {
                public:
                    uint32_t    id;
                    socket      sock;
                    // ... 
                };


                typedef server_tcp_pool_type std::vector<std::shared_ptr<server_tcp>>;
                using server_tcp_by_id_type = std::map<uint32_t, std::shared_ptr<server_tcp>>;

                std::vector<std::shared_ptr<server_tcp>>            server_tcp_pool;
                std::map<uint32_t, std::shared_ptr<server_tcp>>     server_tcp_by_id;
                
                ...

                auto found = server_tcp_by_id.find("toto");
                auto sock = found->second->name;
                ```
            </script>
        </section>

        <!-- Fonction lambda / haut niveau -->
        <section>
            <h3>Idée reçu n°3</h3>
            <h3>"C'est un langage limité et bas niveau"</h3>
        </section>

        <section data-markdown>
            <!-- Reflechir à un cas concret basé sur les callbacks -->
            <!--  Parler de la façon "traditionnelle" de faire des fonctions -->
            <script type="text/template">
                Séquencement d'un serveur
                ```cpp
                class response_interface {
                public:
                    virtual void process_response(const packet& pkt) = 0; 
                };

                class response_mngt
                : public response_interface
                {
                public:
                    void process_response(const packet& pkt) override {
                        check_request(pkt.id);
                        process_data(pkt.data);
                    }

                public:
                    void check_request(uint64_t id) { /* ...*/}

                    template<typename Data>
                    void process_data(Data& ) { /* ... */}
                }

                class server_tcp 
                {
                public:
                    void send(packet&& pkt) { 
                        /* send and receive response */
                        rep_.process_response(resp);
                    }

                    void run() {
                        while (!done()) {
                            packet pkt;

                            send(pkt);
                        }
                    }

                private:
                    response_mngt rep_;
                };
                ```
            </script>
        </section>

        <section data-markdown>
            <!-- Reflechir à un cas concret basé sur les callbacks -->
            <!--  Parler de la façon "traditionnelle" de faire des fonctions -->
            <script type="text/template">
                ### Fonction lambda
                ...où comment se simplifer la vie
                ```cpp
                class response_mngt
                {
                public:
                    void check_request(uint64_t id) { /* ...*/}

                    template<typename Data>
                    void process_data(Data& ) { /* ... */}
                }

                using handle = std::function<void(const packet& )>;

                class server_tcp {
                public:
                    void send(packet&& pkt, handle handle_response) { 
                        /* send and receive response */
                        handle_response(resp);
                    }

                    void run() {
                        while (!done()) {
                            packet pkt;

                            auto response = [this](const packet& res) {
                                rep_.check_response(res.id);
                                rep_.process_data(res.data);
                            };

                            send(pkt, response);
                        }
                    }
                private:
                    response_mngt       rep_;
                };
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Literal
                ...où comment définir ces propres types
                ```cpp
                struct size_value{
                    uint64_t        value = 0;
                };

                size_value operator ""_ko(unsigned long long int v) {
                    size_value result;
                    result.value = v * 1024 * 1024;
                    return result;
                }

                size_value operator ""_mo(unsigned long long int v) {
                    size_value result;
                    result.value = v * 1024;
                    return result;
                }

                auto buffer = 28_mo;    // buffer.value = 29360128
                ```
            </script>
        </section>

        <!-- Librairies STL -->
        <section>
            <h3>Idée reçu n°4</h3>
            <h3>"Il y a pas grand chose dans la librairie standard"</h3>
        </section>

        <section>
            <h3>Le "standard" C++ :</h3>
            <br/>
            <h4><b>La bibliothèque STL</b></h4>
            <p>
                container, thread, filesystem, regexp, chrono, math,...
            </p>
            <br/>
            <h4><b>La bibliothèque BOOST</b></h4>
            <p>
                le reste... (ASIO, GPU, coroutine, fiber, Date, graph, ...) 142 modules
            </p>
        </section>

        <section>
            <h3>Et aussi : l'intégralité des bibliothèques C/C++</h3>
            <img style="border: none; margin-top: 100px;" src="img/613445810_2249c2d193_z.jpg"/>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Quelques exemples:
                * Expandium NX - Framework HTTP asynchrone
                * Facebook Wangle - Framework réseau
                * Facebook Folly - Collection d'utilitaire
                * Librairie Cloud (HDFS MapR)
                * ...
            </script>
        </section>

        <section>
            <h3>Et ce n'est qu'un aperçu</h3>
            <img class="plain" src="img/C-11-CPP-11-features.png"/>
        </section>

        <!-- Phoenix -->
        <section>
            <h2><b>Phoenix</b></h2>
            <p>Comment faire du C++ aujourd'hui</p>
            <div style="margin-top: 100px">
                <img class="plain" width="30%" height="30%" src="img/phoenix.png"/>
            </div>
            <aside class="notes">
                parler des problèmes de build
            </aside>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Toolchain de build

                * Pour gérer un projet C++
                * Pour gérer ses dépendances
                * "Multi plateforme" -> Utilisation de docker
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Exemple d'utilisation
                ```bash
                phoenix-bootstrap
                phoenix-build configure
                phoenix-build build
                phoenix-build install
                phoenix-build run
                ```
            </script>
        </section>

        <!-- Petit exemple comparé -->
        <section>
            <h3>Un petit exemple d'utilisation</h3>
        </section>

        <section>
            <h3>Problématiques data ?</h3>
            <ul>
                <li><strike>$ Learn from the past to predict the future</strike></li>
                <li>No BS : essayer d'aller au delà des KPIs</li>
                <li>Ex: #dropped calls => churn probability</li>
                <li>#calls + #calls_fhz => fraudeur</li>
            </ul>
        </section>

        <section>
            <h3>Données sensibles</h3>
            <h4>Prenons un exemple classique</h4>
            <ul>
                <li>Classification: <b>étiqueter</b>/labelliser des objets (données) comme appartenant à une catégorie parmi plusieurs</li>
                <li>Ex : un utilisateur satisfait ou non; une image comme étant un visage ou un poisson</li>
            </ul>
        </section>

        <section>
            <h3>Classification supervisée</h3>
            <h4>Le modèle apprend à discriminer les catégories à partir de données déjà étiquetées. C'est la phase d'apprentissage</h4>
        </section>

        <section>
            <h3>Apprentissage</h3>
            <img class="plain" src = "img/training.png" alt = "training">
        </section>

        <section>
            <h3>Classification supervisée</h3>
            <h4>Une fois le modèle obtenu, on lui envoie des images non étiquetées et il prédit l'étiquette correspondant</h4>
        </section>

        <section>
            <h3>Prédictions</h3>
            <img class="plain" src = "img/testing.png" alt = "training">
        </section>

        <section>
            <h3>Webservice de classification d'images</h3>
            <h4>C++ versus Python</h4>
        </section>

        <section>
            <h3>CIFAR10</h3>
            <img class="plain" src="img/cifar10.png" alt = "cifar10">
            <h3>Deep learning : CNN (réseau neuronale convolutif)</h3>
            <h3>Derrière un serveur http qui reçoit des images et qui renvoie ce qu'elles représentent</h3>
        </section>

        <section>
            <h3>Réseau neuronale</h3>
            <ul>
                <li>Algorithme d'apprentissage</li>
                <li><b>Inspiré</b> du fonctionnement du cerveau humain</li>
                <li>Perceptron en 1957 par F. Rosenblatt</li>
            </ul>
        </section>

        <section>
            <h3>Réseau neuronale</h3>
            <img class="plain" src = "img/deeplearning.png" alt = "deep learning">
        </section>

        <section>
            <h3>Réseau neuronale</h3>
            <img class="plain" src = "img/neuron.png" alt = "neuron">
        </section>

        <section>
            <h3>Intuition :</h3>
            <ul>
                <li>Si la somme des entrées tend vers +∞ alors la sortie tend vers 1</li>
                <li>Si la somme des entrées tend vers -∞ alors la sortie tend vers 0</li>
            </ul>
        </section>

        <section>
            <h3>Intuition</h3>
            <img class="plain" src = "img/neuron_simple.png" alt = "neuron">
        </section>

        <section>
            <h3>Backpropagation</h3>
            <ul>
                <li>On calcule les sorties à partir des entrées</li>
                <li>On mesure l'erreur</li>
                <li>On fait remonter l'erreur dans le réseau via backpropagation (dérivées partielles) et on modifie les poids en conséquence</li>
            </ul>
        </section>

        <section>
            <h3>Réseau neuronale convolutif</h3>
            <img class="plain"  src = "img/cnn.png" alt = "cnn">
        </section>

        <section>
            <h3>Réseau neuronale convolutif</h3>
            <img class="plain" src = "img/convolution.png" alt = "convolution">
        </section>

        <section>
            <h3>Réseau neuronale convolutif</h3>
            <img class="plain" src = "img/cnn.png" alt = "cnn">
        </section>

        <section>
            <h3>Réseau neuronale convolutif</h3>
            <img class="plain" src = "img/pooling.png" alt = "cnn">
        </section>

        <section>
            <h3>Lib : Caffe</h3>
            <ul>
                <li>Développé en C++ avec wrapper python </li>
                <li>Comme la majorité des solutions...</li>
                <li>La définition du modèle se fait via fichier de config</li>
            </ul>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Http serveur python
                Du classique : Flask
                ```python
                import cPickle as pickle
                import numpy as np
                import json 
                from PIL import Image
                import sys
                import os
                from flask import Flask
                from flask import request
                app = Flask(__name__)
                app.config['UPLOAD_FOLDER'] = '/tmp'
        
                import caffe

                def loadNet():
                    blob = caffe.proto.caffe_pb2.BlobProto()
                    data = open( 'share/mean.binaryproto' , 'rb' ).read()
                    blob.ParseFromString(data)
                    arr = np.array( caffe.io.blobproto_to_array(blob) )
                    net = caffe.Classifier('share/cifar10_quick.prototxt', \
                        'share/cifar10_quick_iter_5000.caffemodel.h5',\
                    image_dims=(32, 32), mean=arr[0],raw_scale=255)

                    return(net)

                net = loadNet()

                @app.route("/predict_from_file", methods = ['POST'])
                def predict_from_file():
                    app.logger.info('Predict OK')
                    if 'upload_file' not in request.files:
                        flash('No file part')
                        return redirect(request.url)
                    file = request.files['upload_file']
                    app.logger.info('file found')
                    if file.filename == '':
                        flash('No Selected file')
                        return redirect(request.url)
                    
                    app.logger.info('File loaded ' + file.filename)
                    filename = file.filename
                    file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
                    
                    x   = net.predict( [ caffe.io.load_image(file) ])
                    return json.dumps(x.tolist())

                if __name__ == "__main__":
                    app.run(host='0.0.0.0')

                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Http serveur C++
                ```cpp
                    int main(){
                        auto proutprout;
                    }

                ```
            </script>
        </section>

        <section>
        <h3>Demo : </h3>
        URL VERS DEMO
        </section>

        <section>
            <h3>Et les perfs ?</h3>
            <ul>
                <li>Python+Caffe+Flask : 30req/s</li>
                <li>Cpp+Caffe+Nx : 60 req/s</li>
            </ul>
        </section>

        <section>
            <h3>Et si on veut étendre Caffe ?</h3>
            <ul>
                <li>Besoin spécifique : eg: layer custom</li>
                <li>Layer jouet : transforme les images RGB en Grayscale</li>
            </ul>
        </section>


        <section data-markdown>
            <script type="text/template">
                ### layer python
                Gray = R*0.2989+G*0.5870+B*0.1140
                ```python
                import caffe
                import numpy as np

                class ColorConvertLayer(caffe.Layer):

                    def setup(self, bottom, top):
                        pass

                    def reshape(self, bottom, top):
                        top[0].reshape(100,1,32,32)
                        

                    def forward(self, bottom, top):
                        top[0].data[:,0,...] = (bottom[0].data[:,0,...] * 0.2989) + (bottom[0].data[:,1,...] * 0.5870) + (bottom[0].data[:,2,...]*0.1140) 


                    def backward(self, top, propagate_down, bottom):
                        pass

 
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### layer cpp
                Gray = R*0.2989+G*0.5870+B*0.1140
                ```cpp
                namespace caffe {

                void 
                GrayLayer<Dtype>::Reshape(const blob_vector_type& bottom, const blob_vector_type& top)
                {
                    // TODO reshape (i dont understand)
                }

                template<typename Dtype>
                void 
                GrayLayer<Dtype>::Forward_cpu(const blob_vector_type& bottom, const blob_vector_type& top)
                {
                    for (size_t i = 0 ; i < top.size() ; ++i) {
                        //top[i]->SharedData();
                     }
                }

                INSTANTIATE_CLASS(GrayLayer);
                REGISTER_LAYER_CLASS(Gray);

                }   // namespace caffe
 
                ```
            </script>
        </section>

        <section>
            <h3>Coût de l'overhead python ?</h3>
            <ul>
                <li>Apprentissage sans layer custom : XXX secs</li>
                <li>Apprentissage avec layer python : XXX secs</li>
                <li>Apprentissage avec layer cpp    : XXX secs</li>
            </ul>
        </section>

        <section>
            <h3>Un petit exemple concret</h3>

        </section>

        <section>
            <h3>Perspectives</h3>
            <ul>
                <li>Utilisation des nouvelles technologies</li>
                <li>Industrialisation des POC DataMining</li>
                <li>Disponibilité des compétences (Go/R)</li>
                <li>Obtenir le maximum d'une architecture hardware</li>
            </ul>
        </section>
        <section>
            <h2>Des questions ?</h2>
        </section>
    </div>
</div>
<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
 
<script>
	// Required, even if empty.
	Reveal.initialize({
        width: 1280,
        height: 1024,
        minScale: 0.2,
        maxScale: 1.0,
        margin: 0.1,
        dependencies: [
            { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'socket.io/socket.io.js', async: true },
	        { src: 'plugin/notes-server/client.js', async: true }
        ]
	});
</script>
</body>
</html>
