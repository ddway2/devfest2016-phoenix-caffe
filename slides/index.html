<html lang="en">
<head>
    <meta charset="utf-8">
    <title>C++ : The beast is Back</title>
    <link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/simple.css" id="theme">
    <link rel="stylesheet" href="css/my_style.css">
    <link rel="stylesheet" href="lib/css/zenburn.css"> 
</head>
<body>
<div class="reveal">
    <div class="slides">
        
        <!-- Titre 1 -->
        <section>
            <h1>C++</h1>
            <h1>The Beast is back !!</h1>
                        
        </section>
        
        <!-- Context -->
        <section>
            <a align="left"><h3>Présentation</h3></a>
            <img class="plain" src="img/expandium-300x164.jpg"/>
            <ul>
                <li>10 ans d'expérience</li>
                <li>Monitoring passif du coeur de réseau d'opérateurs télécom</li>
                <li>Les opérateurs mobiles et les entreprises de chemin de fer (GSM-R)</li>
                <li>Analyse / Business Intelligence</li>
            </ul>
        </section>

        <section>
            <h3>Qui sommes-nous ?</h3>
            <h4>Pierre Salmon</h4>
            TODO: remplir son petit laïus
        </section>

        <section>
            <h3>Qui sommes-nous ?</h3>
            <h4>Nicolas Greffard</h4>
                <ul>
                <li>Data Scientist</li>
                <li>Machine Learning / Analytics</li>
                </ul>
                <img src = "img/data_science_venn.png" alt = "data_science_venn">
        </section>

        <section>
            <h3>Quelles sont nos problématiques ?</h3>
        </section>

        <section>
            <h3>Pourquoi les technologies C++ ?</h3>
        </section>

        <!-- Slide C++ -->
        <!-- Historique C++ -->
        <section>
            <h3>Au commencement : 1983</h3>
            <h4>C with Classes</h4>
        </section>
        
        <section>
            <h3>1998 : standard ISO</h3>
        </section>

        <section>
            <h3>2003 : Une petite révision</h3>
        </section>

        <section>
            <h3>2011 - 2014 : Le renouveau</h3>
            <ul>
                <li>Le langage C++</li>
                <li>La bibliothèque Standard (STL)</li>
                <li>La bibliothèque boost</li>
            </ul>
        </section>

        <section>
            <img class="plain" src="img/cpp-evolution-path.svg"/>
        </section>

        <!-- Présentation des nouveauté -->
        <!-- Idée reçu n°1 -->
        <section>
            <h3>Idée reçu n°1 : <h3>
            <h3>"Il n'y a pas de Garbage Collector : il faut gérer soi même la mémoire"</h3>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Souvenir, souvenir...
                ```cpp
                struct buffer {
                    uint8_t   value[65536];
                };

                buffer* b = new buffer();
                
                ...

                delete b;
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Smart Pointer
                ```cpp
                #include <memory>

                using buffer_ptr = std::shared_ptr<buffer>;
                buffer_ptr b = std::make_shared<buffer>();

                /// Live your life b variable...
                ```
            </script>
        </section>

        <!-- Mot clé auto -->
        <section>
            <h3>Idée reçu n°2</h3>
            <h3>"Il y a des déclarations de type partout ! Sans IDE c'est trop dure'"
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Rechercher un élément dans un hash
                ```cpp
                struct foo {
                    std::string name;
                    int id;
                };

                std::map<std::string, foo>  my_hash;
                
                ...

                std::map<std::string, foo>::iterator found = my_hash.find("toto");
                std::string my_name = found->second.name;
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### auto à notre secour...
                ```cpp
                struct foo {
                    std::string name;
                    int id;
                };

                std::map<std::string, foo>  my_hash;

                ...

                auto found = my_hash.find("toto");
                auto my_name = found->second.name;
                ```
            </script>
        </section>

        <!-- Fonction lambda / haut niveau -->
        <section>
            <h3>Idée reçu n°3</h3>
            <h3>"C'est un langage limité bas niveau"</h3>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Fonction lambda
                ...où comment faire des fonctions anonymes
                ```cpp
                auto f1 = [](const std::string& value) {
                    std::cout << "value: " << value << std::endl;
                };

                f1("salut");

                int i = 0;
                auto f2 = [&i]() { ++i; };

                f2();   
                std::cout << "i = " << i << std::endl;      // i = 1

                int j = 0;
                auto f3 = [j]() {
                    ++j;
                    std::cout << "j = " << j << std::endl;  // j = 1
                };

                std::cout << "j = " << j << std::endl;     // j = 0
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Tuples
                ...où comment jouer avec des structures simples
                ```cpp
                int n = 1;
                auto t1 = std::make_tuple(10, "toto", n);

                int value1, value3;
                std::string value2;

                std::tie(value1, value2, value3) = t1; 
                ```
            </script>
        </section>

        <!-- Librairies STL -->
        <section>
            <h3>Idée reçu n°4</h3>
            <h3>"Il y a pas grand chose dans la librairie standard"</h3>
        </section>

        <section>
            <h3>Le "standard" C++ :</h3>
            <br/>
            <h4><b>La bibliothèque STL</b></h4>
            <p>
                container, thread, filesystem, regexp, chrono, math,...
            </p>
            <br/>
            <h4><b>La bibliothèque BOOST</b></h4><img src="img/boost-c-logo.jpg"/>
            <p>
                le reste... (ASIO, GPU, coroutine, fiber, Date, graph, ...) 142 modules
            </p>
        </section>

        <section>
            Et aussi : l'intégralité des bibliothèques C/C++ existente
        </section>

        <section>
            <h3>Et ce n'est qu'un aperçu</h3>
            <img class="plain" src="img/C-11-CPP-11-features.png"/>
        </section>

        <!-- Petit exemple comparé -->
        <section data-markdown>
            <script type="text/template">
                ```cpp

                ```
            </script>
        </section>

        <!-- Phoenix -->
        <section>
            <h2><b>Phoenix</b></h2>
            <p>ou comment faire du C++ aujourd'hui</p>
            <img class="plain" width="30%" height="30%" src="img/phoenix.png"/>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Toolchain de build

                * Pour gérer un projet C++
                * Pour gérer ses dépendances
                * "Multi plateforme" -> Utilisation de docker
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### exemple d''utilisation

                ```bash
                phoenix-bootstrap
                ```
            </script>
        </section>

        <section>
            <h3>Problématiques data ?</h3>
            <ul>
                <li><strike>$ Learn from the past to predict the future</strike></li>
                <li>No BS : essayer d'aller au delà des KPIs</li>
                <li>Ex: #dropped calls => churn probability</li>
                <li>#calls + #calls_fhz => fraudeur</li>
            </ul>
        </section>

        <section>
            <h3>Données sensibles</h3>
            <h4>Prenons un exemple classique</h4>
            <ul>
                <li>Classification: <b>étiqueter</b>/labelliser des objets (données) comme appartenant à une catégorie parmi plusieurs</li>
                <li>Ex : un utilisateur satisfait ou non; une image comme étant un visage ou un poisson</li>
            </ul>
        </section>

        <section>
            <h3>Classification supervisée</h3>
            <h4>Le modèle apprend à discriminer les catégories à partir de données déjà étiquetées. C'est la phase d'apprentissage</h4>
        </section>

        <section>
            <h3>Apprentissage</h3>
            <img src = "img/training.png" alt = "training">
        </section>

        <section>
            <h3>Classification supervisée</h3>
            <h4>Une fois le modèle obtenu, on lui envoie des images non étiquetées et il prédit l'étiquette correspondant</h4>
        </section>

        <section>
            <h3>Prédictions</h3>
            <img src = "img/testing.png" alt = "training">
        </section>

        <section>
            <h3>Webservice de classification d'images</h3>
            <h4>C++ versus Python</h4>
        </section>

        <section>
            <h3>CIFAR10</h3>
            <img src="img/cifar10.png" alt = "cifar10">
            <h3>Deep learning : CNN (réseau neuronale convolutif)</h3>
            <h3>Derrière un serveur http qui reçoit des images et qui renvoie ce qu'elles représentent</h3>
        </section>

        <section>
            <h3>Réseau neuronale convolutif</h3>
            <ul>
                <li><b>Inspiré</b> du fonctionnement du cerveau humain</li>
                <li>...</li>
            </ul>
        </section>

        <section>
            <h3>Lib : Caffe</h3>
            <ul>
                <li>Développé en C++ avec wrapper python </li>
                <li>Comme la majorité des solutions...</li>
                <li>La définition du modèle se fait via fichier de config</li>
            </ul>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Http serveur python
                Du classique : Flask
                ```python
                import sys
                
                import cPickle as pickle
                import numpy as np
                import caffe
                
                import json 
                from PIL import Image
                
                from flask import Flask
                from flask import request
                app = Flask(__name__)


                def loadNet():
                    blob = caffe.proto.caffe_pb2.BlobProto()
                    data = open( '../../caffe/examples/cifar10/mean.binaryproto' , 'rb' ).read()
                    blob.ParseFromString(data)
                    arr = np.array( caffe.io.blobproto_to_array(blob) )
                    net = caffe.Classifier('../../caffe/examples/cifar10/cifar10_quick.prototxt', \
                    '../../caffe/examples/cifar10/cifar10_quick_iter_5000.caffemodel.h5',\
                    image_dims=(32, 32), mean=arr[0],raw_scale=255)

                    return(net)


                @app.route("/predict_from_file", methods=['GET', 'POST'])
                def test():
                    net = loadNet()
                    x   = net.predict( [ caffe.io.load_image('../../caffe/examples/images/cat.jpg') ])
                    return json.dumps(x.tolist())

                @app.route("/predict_one", methods = ['GET', 'POST'])
                def predict_one():
                    img = json.loads(request.json)
                    net = loadNet()
                    x   = net.predict( [ caffe.io.load_image(img) ])
                    print(img)
                    print(x)
                    return json.dumps(x.tolist())

                if __name__ == "__main__":
                    app.run() 
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Http serveur C++
                ```cpp
                    int main(){
                        auto proutprout;
                    }

                ```
            </script>
        </section>

        <section>
            <h3>Et les perfs ?</h3>
            <ul>
                <li>Python+Caffe+Flask : 30req/s</li>
                <li>Cpp+Caffe+Nx : 60 req/s</li>
            </ul>
        </section>

        <section>
            <h3>Et si on veut étendre Caffe ?</h3>
            <ul>
                <li>Besoin spécifique : eg: layer custom</li>
                <li>Layer jouet : transforme les images RGB en Grayscale</li>
            </ul>
        </section>


        <section data-markdown>
            <script type="text/template">
                ### layer python
                Gray = R*0.2989+G*0.5870+B*0.1140
                ```python
                import caffe
                import numpy as np

                class ColorConvertLayer(caffe.Layer):

                    def setup(self, bottom, top):
                        pass

                    def reshape(self, bottom, top):
                        top[0].reshape(100,1,32,32)
                        

                    def forward(self, bottom, top):
                        top[0].data[:,0,...] = (bottom[0].data[:,0,...] * 0.2989) + (bottom[0].data[:,1,...] * 0.5870) + (bottom[0].data[:,2,...]*0.1140) 


                    def backward(self, top, propagate_down, bottom):
                        pass

 
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### layer cpp
                Gray = R*0.2989+G*0.5870+B*0.1140
                ```cpp
                namespace caffe {

                void 
                GrayLayer<Dtype>::Reshape(const blob_vector_type& bottom, const blob_vector_type& top)
                {
                    // TODO reshape (i dont understand)
                }

                template<typename Dtype>
                void 
                GrayLayer<Dtype>::Forward_cpu(const blob_vector_type& bottom, const blob_vector_type& top)
                {
                    for (size_t i = 0 ; i < top.size() ; ++i) {
                        //top[i]->SharedData();
                     }
                }

                INSTANTIATE_CLASS(GrayLayer);
                REGISTER_LAYER_CLASS(Gray);

                }   // namespace caffe
 
                ```
            </script>
        </section>

        <section>
            <h3>Coût de l'overhead python ?</h3>
            <ul>
                <li>Apprentissage sans layer custom : XXX secs</li>
                <li>Apprentissage avec layer python : XXX secs</li>
                <li>Apprentissage avec layer cpp    : XXX secs</li>
            </ul>
        </section>

    </div>
</div>
<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
 
<script>
	// Required, even if empty.
	Reveal.initialize({
        width: 1280,
        height: 1024,
        minScale: 0.2,
        maxScale: 1.0,
        margin: 0.1,
        dependencies: [
            { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
	});
</script>
</body>
</html>