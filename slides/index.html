<html lang="en">
<head>
    <meta charset="utf-8">
    <title>C++ : The beast is Back</title>
    <link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/simple.css" id="theme">
    <link rel="stylesheet" href="css/my_style.css">
    <link rel="stylesheet" href="lib/css/zenburn.css"> 
</head>
<body>
<div class="reveal">
    <div class="slides">
        
        <!-- Titre 1 -->
        <section>
            <h1>C++</h1>
            <h1>The Beast is back !!</h1>
                        
        </section>
        
        <!-- Context -->
        <section>
            <a align="left"><h3>Présentation</h3></a>
            <img src="img/expandium-300x164.jpg" width="30%" style="float: right; border: none;"/>
            <div class="ulist">
                <ul style="width: 60%">
                    <li>10 ans d'expérience</li>
                    <li>Monitoring passif du coeur de réseau d'opérateurs télécom</li>
                    <li>Les opérateurs mobiles et les entreprises de chemain de fer (GSM-R)</li>
                    <li>Analyse / Business Intelligence</li>
                </ul>
            </div>
        </section>

        <section>
            <h3>Qui sommes-nous ?</h3>
            <h4>Pierre Salmon</h4>
                <img class="plain" src="img/cpp_img.jpg"/>
        </section>

        <section>
            <h3>Qui sommes-nous ?</h3>
            <h4>Nicolas Greffard</h4>
                <img class="plain" src = "img/data_science_venn.png" alt = "data_science_venn">
        </section>

        <section>
            <h2>Quelles sont nos problématiques ?</h2>
        </section>

        <section>
            <img width="30%" style="float:right; border: none; box-shadow: none" src="img/big-data.jpg"/>
            <ul style="width: 60%">
                <li>Gestion de gros volume</li>
                <li>Capacité de traitement</li>
                <li>Contrainte hardware</li>
                <li>Données sensibles</li>
                <li>Coût de maintenance</li>
            </ul>
        </section>

        <section>
            <h2>Pourquoi les technologies C++ ?</h2>
            <aside class="notes">
                <ul>
                <li>Performance</li>
                <li>Compétence</li>
                <li>Haut niveau / Matos</li>
                <li>Librairie existante</li>
                </ul>
            </aside>
        </section>

        <!-- Slide C++ -->
        <!-- Historique C++ -->
        <section>
            <h2>Au commencement : 1983</h2>
            <h3>C with Classes</h3>
            <div style="margin-top: 100px;">
                <img class="plain" src="img/220px-BjarneStroustrup.jpg"/>
                <h6>Bjarne Stroustrup</h6>
            </div>
        </section>
        
        <section>
            <h2>1998 : standard ISO</h2>
            <div style="margin-top: 100px">
                <img class="plain" src="img/iso_logo.gif"/>
            </div>
        </section>

        <section>
            <h2>2003 : Une petite révision</h2>
        </section>

        <section>
            <h2>2011 - 2014 : Le renouveau</h2>
            <div style="margin-top: 100px">
                <ul>
                    <li>Le langage C++</li>
                    <li>La bibliothèque Standard (STL)</li>
                    <li>La bibliothèque boost</li>
                </ul>
            </div>
        </section>

        <section>
            <img class="plain" src="img/cpp-evolution-path.svg"/>
        </section>

        <!-- Présentation des nouveauté -->
        <section>
            <h2>Luttons contre les idées reçus</h2>
        </section>

        <!-- Idée reçu n°1 -->
        <section>
            <h3>Idée reçu n°1 : <h3>
            <h3>"Il n'y a pas de Garbage Collector : il faut gérer soi même la mémoire"</h3>
        </section>

        <section data-markdown>
            <script type="text/template">
                L'envoi d'un paquet sur le réseau
                ```cpp
                struct network_packet {
                    uint8_t   value[65536];
                };

                network_packet* pkt = new network_packet();
                
                ... traitement / envoi

                delete pkt;
                ```
                Ce n'est pas des plus pratiques...
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Smart Pointer
                Le pointeur partagé
                ```cpp
                #include <memory>

                std::shared_ptr<network_packet> b = std::make_shared<network_packet>();

                /// Live your life b variable...
                ```
            </script>
        </section>

        <section>
            <h3>Idée reçu n°2 : <h3>
            <h3>"Je comprends rien aux paramètres des fonctions"</h3>
        </section>

        <section data-markdown>
            <script type="text/template">
                Passage par valeur
                ```cpp
                void send(network_packet p) { ... }     // Passage par valeur

                void loop() {
                    network_packet pkt;

                    send(pkt);                          // Copie de l'objet (64Ko à chaque appel !!)
                }
                ```

            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                Passage par référence
                ```cpp
                void send(network_packet& p) { ... }     // Passage par référence

                void loop() {
                    network_packet pkt;

                    send(pkt);                          // seul une référence vers l'objet est passée 
                }
                ```
            </script>
        </section>

        <section data-markdown>
            <!-- Faire un exemple en mode client serveur -->
            <script type="text/template">
                ### Move Semantic
                ...ou comment gérer la vie d'une variable
                ```cpp
                void send(network_packet&& p) { ... }     // Passage par rvalue

                void loop() {
                    network_packet pkt;

                    send(std::move(pkt));                // Le control de l'objet pkt passe à la fonction send 
                }
                ```
            </script>
        </section>

        <!-- Mot clé auto -->
        <section>
            <h3>Idée reçu n°3</h3>
            <h3>"Il y a des déclarations de type partout ! </h3>
            <h3>Sans IDE c'est trop dure'"</h3>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Rechercher de l'instance d'un serveur
                ```cpp
                struct server {
                    std::string name;
                    int socket;
                };

                std::map<std::string, server>  server_pool;
                
                ...

                std::map<std::string, foo>::iterator found = server_pool.find("toto");
                std::string my_name = found->second.name;
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                On peut toujours utilisé un typedef
                ```cpp
                struct server {
                    std::string name;
                    int socket;
                };

                typedef std::map<std::string, server> server_pool_type;
                server_pool_type  server_pool;
                
                ...

                server_pool_type::iterator found = server_pool.find("toto");
                std::string my_name = found->second.name;
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Le mot clé auto à la rescousse...
                ```cpp
                struct server {
                    std::string name;
                    int socket;
                };

                std::map<std::string, server>  server_pool;
                
                ...

                auto found = server_pool.find("toto");
                auto my_name = found->second.name;
                ```
            </script>
        </section>

        <!-- Fonction lambda / haut niveau -->
        <section>
            <h3>Idée reçu n°4</h3>
            <h3>"C'est un langage limité et bas niveau"</h3>
        </section>

        <section data-markdown>
            <!-- Reflechir à un cas concret basé sur les callbacks -->
            <!--  Parler de la façon "traditionnelle" de faire des fonctions -->
            <script type="text/template">
                ### Fonction lambda
                ...où comment faire des fonctions anonymes
                ```cpp
                auto f1 = [](int value) {
                    std::cout << "value: " << value << std::endl;
                };

                int i = 0;
                auto f2 = [&i]() { ++i; };

                f2();   
                std::cout << "i = " << i << std::endl;      // i = 1

                int j = 0;
                auto f3 = [j]() {
                    ++j;
                    std::cout << "j = " << j << std::endl;  // j = 1
                };

                std::cout << "j = " << j << std::endl;     // j = 0
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Tuples
                ...où comment jouer avec des structures simples
                ```cpp
                int n = 1;
                auto t1 = std::make_tuple(10, "toto", n);

                int value1, value3;
                std::string value2;

                std::tie(value1, value2, value3) = t1; 
                ```
            </script>
        </section>

        <!-- Librairies STL -->
        <section>
            <h3>Idée reçu n°5</h3>
            <h3>"Il y a pas grand chose dans la librairie standard"</h3>
        </section>

        <section>
            <h3>Le "standard" C++ :</h3>
            <br/>
            <h4><b>La bibliothèque STL</b></h4>
            <p>
                container, thread, filesystem, regexp, chrono, math,...
            </p>
            <br/>
            <h4><b>La bibliothèque BOOST</b></h4>
            <p>
                le reste... (ASIO, GPU, coroutine, fiber, Date, graph, ...) 142 modules
            </p>
        </section>

        <section>
            <h3>Et aussi : l'intégralité des bibliothèques C/C++</h3>
            <img style="border: none; margin-top: 100px;" src="img/613445810_2249c2d193_z.jpg"/>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Quelques exemples:
                * Expandium NX - Framework HTTP asynchrone
                * Facebook Wangle - Framework réseau
                * Facebook Folly - Collection d'utilitaire
                * Librairie Cloud (HDFS MapR)
                * ...
            </script>
        </section>

        <section>
            <h3>Et ce n'est qu'un aperçu</h3>
            <img class="plain" src="img/C-11-CPP-11-features.png"/>
        </section>

        <!-- Phoenix -->
        <section>
            <h2><b>Phoenix</b></h2>
            <p>comment faire du C++ aujourd'hui</p>
            <div style="margin-top: 100px">
                <img class="plain" width="30%" height="30%" src="img/phoenix.png"/>
            </div>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Toolchain de build

                * Pour gérer un projet C++
                * Pour gérer ses dépendances
                * "Multi plateforme" -> Utilisation de docker
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Exemple d'utilisation
                ```bash
                phoenix-bootstrap
                phoenix-build configure
                phoenix-build build
                phoenix-build install
                phoenix-build run
                ```
            </script>
        </section>

        <!-- Petit exemple comparé -->
        <section>
            <h3>Un petit exemple d'utilisation</h3>
        </section>

        <section>
            <h3>Problématiques data ?</h3>
            <ul>
                <li><strike>$ Learn from the past to predict the future</strike></li>
                <li>No BS : essayer d'aller au delà des KPIs</li>
                <li>Ex: #dropped calls => churn probability</li>
                <li>#calls + #calls_fhz => fraudeur</li>
            </ul>
        </section>

        <section>
            <h3>Données sensibles</h3>
            <h4>Prenons un exemple classique</h4>
            <ul>
                <li>Classification: <b>étiqueter</b>/labelliser des objets (données) comme appartenant à une catégorie parmi plusieurs</li>
                <li>Ex : un utilisateur satisfait ou non; une image comme étant un visage ou un poisson</li>
            </ul>
        </section>

        <section>
            <h3>Classification supervisée</h3>
            <h4>Le modèle apprend à discriminer les catégories à partir de données déjà étiquetées. C'est la phase d'apprentissage</h4>
        </section>

        <section>
            <h3>Apprentissage</h3>
            <img class="plain" src = "img/training.png" alt = "training">
        </section>

        <section>
            <h3>Classification supervisée</h3>
            <h4>Une fois le modèle obtenu, on lui envoie des images non étiquetées et il prédit l'étiquette correspondant</h4>
        </section>

        <section>
            <h3>Prédictions</h3>
            <img class="plain" src = "img/testing.png" alt = "training">
        </section>

        <section>
            <h3>Webservice de classification d'images</h3>
            <h4>C++ versus Python</h4>
        </section>

        <section>
            <h3>CIFAR10</h3>
            <img class="plain" src="img/cifar10.png" alt = "cifar10">
            <h3>Deep learning : CNN (réseau neuronale convolutif)</h3>
            <h3>Derrière un serveur http qui reçoit des images et qui renvoie ce qu'elles représentent</h3>
        </section>

        <section>
            <h3>Réseau neuronale</h3>
            <ul>
                <li>Algorithme d'apprentissage</li>
                <li><b>Inspiré</b> du fonctionnement du cerveau humain</li>
                <li>Perceptron en 1957 par F. Rosenblatt</li>
            </ul>
        </section>

        <section>
            <h3>Réseau neuronale</h3>
            <img class="plain" src = "img/deeplearning.png" alt = "deep learning">
        </section>

        <section>
            <h3>Réseau neuronale</h3>
            <img class="plain" src = "img/neuron.png" alt = "neuron">
        </section>

        <section>
            <h3>Intuition :</h3>
            <ul>
                <li>Si la somme des entrées tend vers +∞ alors la sortie tend vers 1</li>
                <li>Si la somme des entrées tend vers -∞ alors la sortie tend vers 0</li>
            </ul>
        </section>

        <section>
            <h3>Intuition</h3>
            <img class="plain" src = "img/neuron_simple.png" alt = "neuron">
        </section>

        <section>
            <h3>Backpropagation</h3>
            <ul>
                <li>On calcule les sorties à partir des entrées</li>
                <li>On mesure l'erreur</li>
                <li>On fait remonter l'erreur dans le réseau via backpropagation (dérivées partielles) et on modifie les poids en conséquence</li>
            </ul>
        </section>

        <section>
            <h3>Réseau neuronale convolutif</h3>
            <img class="plain"  src = "img/cnn.png" alt = "cnn">
        </section>

        <section>
            <h3>Réseau neuronale convolutif</h3>
            <img class="plain" src = "img/convolution.png" alt = "convolution">
        </section>

        <section>
            <h3>Réseau neuronale convolutif</h3>
            <img class="plain" src = "img/cnn.png" alt = "cnn">
        </section>

        <section>
            <h3>Réseau neuronale convolutif</h3>
            <img class="plain" src = "img/pooling.png" alt = "cnn">
        </section>

        <section>
            <h3>Lib : Caffe</h3>
            <ul>
                <li>Développé en C++ avec wrapper python </li>
                <li>Comme la majorité des solutions...</li>
                <li>La définition du modèle se fait via fichier de config</li>
            </ul>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Http serveur python
                Du classique : Flask
                ```python
                import cPickle as pickle
                import numpy as np
                import json 
                from PIL import Image
                import sys
                import os
                from flask import Flask
                from flask import request
                app = Flask(__name__)
                app.config['UPLOAD_FOLDER'] = '/tmp'
        
                import caffe

                def loadNet():
                    blob = caffe.proto.caffe_pb2.BlobProto()
                    data = open( 'share/mean.binaryproto' , 'rb' ).read()
                    blob.ParseFromString(data)
                    arr = np.array( caffe.io.blobproto_to_array(blob) )
                    net = caffe.Classifier('share/cifar10_quick.prototxt', \
                        'share/cifar10_quick_iter_5000.caffemodel.h5',\
                    image_dims=(32, 32), mean=arr[0],raw_scale=255)

                    return(net)

                net = loadNet()

                @app.route("/predict_from_file", methods = ['POST'])
                def predict_from_file():
                    app.logger.info('Predict OK')
                    if 'upload_file' not in request.files:
                        flash('No file part')
                        return redirect(request.url)
                    file = request.files['upload_file']
                    app.logger.info('file found')
                    if file.filename == '':
                        flash('No Selected file')
                        return redirect(request.url)
                    
                    app.logger.info('File loaded ' + file.filename)
                    filename = file.filename
                    file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
                    
                    x   = net.predict( [ caffe.io.load_image(file) ])
                    return json.dumps(x.tolist())

                if __name__ == "__main__":
                    app.run(host='0.0.0.0')

                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### Http serveur C++
                ```cpp
                    int main(){
                        auto proutprout;
                    }

                ```
            </script>
        </section>

        <section>
        <h3>Demo : </h3>
        URL VERS DEMO
        </section>

        <section>
            <h3>Et les perfs ?</h3>
            <ul>
                <li>Python+Caffe+Flask : 30req/s</li>
                <li>Cpp+Caffe+Nx : 60 req/s</li>
            </ul>
        </section>

        <section>
            <h3>Et si on veut étendre Caffe ?</h3>
            <ul>
                <li>Besoin spécifique : eg: layer custom</li>
                <li>Layer jouet : transforme les images RGB en Grayscale</li>
            </ul>
        </section>


        <section data-markdown>
            <script type="text/template">
                ### layer python
                Gray = R*0.2989+G*0.5870+B*0.1140
                ```python
                import caffe
                import numpy as np

                class ColorConvertLayer(caffe.Layer):

                    def setup(self, bottom, top):
                        pass

                    def reshape(self, bottom, top):
                        top[0].reshape(100,1,32,32)
                        

                    def forward(self, bottom, top):
                        top[0].data[:,0,...] = (bottom[0].data[:,0,...] * 0.2989) + (bottom[0].data[:,1,...] * 0.5870) + (bottom[0].data[:,2,...]*0.1140) 


                    def backward(self, top, propagate_down, bottom):
                        pass

 
                ```
            </script>
        </section>

        <section data-markdown>
            <script type="text/template">
                ### layer cpp
                Gray = R*0.2989+G*0.5870+B*0.1140
                ```cpp
                namespace caffe {

                void 
                GrayLayer<Dtype>::Reshape(const blob_vector_type& bottom, const blob_vector_type& top)
                {
                    // TODO reshape (i dont understand)
                }

                template<typename Dtype>
                void 
                GrayLayer<Dtype>::Forward_cpu(const blob_vector_type& bottom, const blob_vector_type& top)
                {
                    for (size_t i = 0 ; i < top.size() ; ++i) {
                        //top[i]->SharedData();
                     }
                }

                INSTANTIATE_CLASS(GrayLayer);
                REGISTER_LAYER_CLASS(Gray);

                }   // namespace caffe
 
                ```
            </script>
        </section>

        <section>
            <h3>Coût de l'overhead python ?</h3>
            <ul>
                <li>Apprentissage sans layer custom : XXX secs</li>
                <li>Apprentissage avec layer python : XXX secs</li>
                <li>Apprentissage avec layer cpp    : XXX secs</li>
            </ul>
        </section>

        <section>
            <h3>Un petit exemple concret</h3>

        </section>

        <section>
            <h3>Perspectives</h3>
            <ul>
                <li>Utilisation des nouvelles technologies</li>
                <li>Industrialisation des POC DataMining</li>
                <li>Disponibilité des compétences (Go/R)</li>
                <li>Obtenir le maximum d'une architecture hardware</li>
            </ul>
        </section>
        <section>
            <h2>Des questions ?</h2>
        </section>
    </div>
</div>
<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
 
<script>
	// Required, even if empty.
	Reveal.initialize({
        width: 1280,
        height: 1024,
        minScale: 0.2,
        maxScale: 1.0,
        margin: 0.1,
        dependencies: [
            { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'socket.io/socket.io.js', async: true },
	        { src: 'plugin/notes-server/client.js', async: true }
        ]
	});
</script>
</body>
</html>
